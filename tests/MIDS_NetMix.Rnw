\documentclass[11pt]{article}
\usepackage{latexsym,amssymb,bm,amsmath,fancybox,graphicx}
\usepackage[bookmarks=true, bookmarksopen=true, linkcolor=webred]{hyperref}
\addtolength{\hoffset}{-0.75in} \addtolength{\voffset}{-0.75in}
\addtolength{\textwidth}{1.5in} \addtolength{\textheight}{1.6in}



% === dcolumn package ===
\usepackage{dcolumn}
\newcolumntype{.}{D{.}{.}{-1}}
\newcolumntype{d}[1]{D{.}{.}{#1}}

% === more new math commands
\renewcommand\r{\right}
\renewcommand\l{\left}
\newcommand\E{\mathbb{E}}
\newcommand\Var{\mathbb{V}}
\newcommand\avar{{\rm Avar}}
\newcommand\dist{\buildrel\rm d\over\sim}
\newcommand\iid{\stackrel{\rm i.i.d.}{\sim}}
\newcommand\ind{\stackrel{\rm indep.}{\sim}}
\newcommand\cov{{\rm Cov}}
\newcommand{\R}{\textbf{R}}
\newcommand\indep{\protect\mathpalette{\protect\independenT}{\perp}}
\def\independenT#1#2{\mathrel{\rlap{$#1#2$}\mkern2mu{#1#2}}}
\DeclareMathOperator{\sgn}{sgn}

% === spacing
\newcommand\spacingset[1]{\renewcommand{\baselinestretch}%
{#1}\small\normalsize}
\spacingset{1.2}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\SweaveOpts{concordance=TRUE}
\setkeys{Gin}{width=0.8\textwidth}

<<echo=FALSE>>=
library(knitr)
opts_chunk$set(comment = "", prompt = TRUE, fig.width=8, fig.height=8, results = 'markup')
opts_chunk$set(tidy = FALSE,
               fig.align = "center",
               background = '#EEEEEE',
               fig.width = 7,
               fig.height = 7,
               out.width =".7\\linewidth",
               out.height = ".7\\linewidth",
               cache = TRUE,
               size = "small"
               )
options(width = 60)
@


\title{\bf NetMix Application: \\ Militarized Interstate Dispute Network}
\author{}
\date{}

\maketitle

\noindent We apply the model to a dynamic network of countries linked by interstate conflict.  Nodes are the 164 countries that are present in the 1816-2010 period.  Nodes enter and exit the network as countries move in and out of the international system.  Edges represent the presence of a militarized dispute between countries in a given year.  We measure edges using version 4.1 of the undirected Militarized Interstate Dispute (MID) dataset.  The dependent variable comprises 625,134 country dyad-years or 195 sociomatrices of size 164 $\times$ 164.
\\

\noindent We include two monadic covariates: a measure of countries' regime type (polity scores from the Polity IV dataset), and their military capability (logged CINC scores from the Correlates of War National Material Capabilities dataset).  Dyadic covariates include an indicator for the presence of an alliance between countries, a separate indicator for the presence of a defense pact, the logged geographic distance between countries, an indicator for contiguity, and a cubic spline for peace years.  

\bigskip

<<1, eval=FALSE, echo=TRUE, comment=NA, message=FALSE, warning=FALSE, tidy=TRUE>>=
load("~/Dropbox/NetMix/tests/MIDdata.Rdata") 
MID_dyad47 <- MID_dyad[MID_dyad$year %in% 1947:2004,]
MID_monad47 <- MID_monad[MID_monad$year %in% 1947:2004,]

library(NetMix)  
set.seed(9999)
fit_onset <- mmsbm(formula.dyad = MID_onset ~ trade_dep_low + IGOmems_joint + 
                               ally + contiguity + dist + peaceyrs_1947 + 
                               spline1_1947 + spline2_1947 + spline3_1947,
                               formula.monad =  ~ polity + logNMC, #+ NATO + WP,
                               data.dyad = MID_dyad47, data.monad = MID_monad47,
                               senderID = "country1", receiverID = "country2", 
                               nodeID = "country", 
                               timeID = "year",
                               n.groups = 4, 
                               n.hmmstates = 2,
                               directed=FALSE,
                               #missing="listwise deletion",
                               mmsbm.control = list(#init="kmeans",
                                                    verbose = TRUE,
                                                    em_iter = 3000,
                                                    #mu_b = c(0, 0),
                                                    #var_b = c(50, 50),
                                                    #var_xi = 0.01,
                                                    #eta = 200,
                                                    threads = parallel::detectCores()
                                                    ))

save(fit_onset, file="~/Dropbox/NM.Rdata")
load("~/Dropbox/NM.Rdata")

cluster.time(fit_onset) 

fit_onset$call
fit_onset$Kappa
rowMeans(fit_onset$Kappa)
fit_onset$TransitionKernel

summary(fit_onset) # monadic coefficients very similar w/in Markov state

mean(fit_onset$dyadic.data$MID_onset)
mean(predict(fit_onset, type="response")) 
mean(predict(fit_onset, type="response", parametric_mm = TRUE))


plot(fit_onset)
colSums(exp(fit_onset$BlockModel) / (1 + exp(fit_onset$BlockModel))) 
summary(fit_onset) 
plot(fit_onset$Kappa[1,])
head(fit_onset) 
cluster.mems(fit_onset, 1947:1990) # error with Sao Tome name
cluster.mems(fit_onset, 1990:2004, 10)

plot.states(fit_onset, c("USA", "Russia", "China", "Switzerland", "Costa Rica", "Iran"))

p <- covFX(fit_onset, "polity", 3) 
p[[1]]
head(sort(p[[3]])) # countries made more peaceful by pos shift in polity
head(sort(p[[3]], decreasing=T)) # countries made more violent 
hist(p[[4]], breaks=50)

pols <- -10:10
Russia.pols <- c()
R.mid <- predict(fit_onset, type="prediction", outcome="probability")
for(i in pols){
  new.dat <- fit_onset$monadic.data
  new.dat[new.dat$`(nid)`=="Russia","polity"] <- i
  R.mid2 <- predict(fit_onset, new.data.monad=new.dat, type="prediction", outcome="probability")
  Russia.pols <- c(Russia.pols, mean((R.mid2 - R.mid)[fit_onset$dyadic.data$`(sid)`=="Russia" | fit_onset$dyadic.data$`(rid)`=="Russia"]))
}
plot(-10:10, Russia.pols, type="l")



fit_onset$Kappa # markov states are constant

cor(tapply(fit_onset$MixedMembership[1,], fit_onset$monadic.data$`(tid)`, mean), 
    tapply(MID_dyad$MID_onset, MID_dyad$year, sum)) # group 1 picking up much of the conflict



source("~/Documents/NetMix/Extra/NetGenerator.R")
set.seed(9999)
sim <- NetSim(BLK=3, NODE=50, STATE=1, TIME=20, DIRECTED=TRUE, N_PRED=3,
                  beta_arr = array(rnorm(12), dim=c(4,3,2)),
                  gamma_vec = rnorm(3, 2, 0.1))

f <-  mmsbm(formula.dyad = Y ~ 1,
            formula.monad = ~ V1 + V2 + V3,
            data.dyad = sim$dyad.data, 
            data.monad = sim$monad.data,
            senderID="sender", receiverID="receiver",
            nodeID="node", timeID="year",
            n.groups=sim$BLK, n.hmmstates=sim$STATE,
            directed=TRUE,
            mmsbm.control = list(verbose = TRUE,
                                 threads = parallel::detectCores()))
plot(f)
mean(sim$dyad.data$Y) 
mean(predict(f, type="response"))
mean(predict(f, type="response", parametric_mm=TRUE)) # overpredicting at this density

cluster.time(f)


## See how predicted density varies in sparsity of networks
v <- c(seq(from=-4, to=0, by=0.1), seq(from=0, to=2, by=0.05))
est.mm <- est.nmm <- tm <- rep(NA, length(v))
tblock <- eblock <- tmonad <- emonad <- vector("list", length(v)) 
for(i in v){
  sim <- NetSim(BLK=3, NODE=25, STATE=2, TIME=5, DIRECTED=TRUE, N_PRED=3,
                  beta_arr = array(rnorm(12), dim=c(4,3,2)),
                  gamma_vec = rnorm(3, i, 0.1), alpha_conc = 0.15)
  tm[which(v==i)] <- mean(sim$dyad.data$Y) 
  f <-  mmsbm(formula.dyad = Y ~ V1 + V2 + V3,
            formula.monad = ~ V1 + V2 + V3,
            data.dyad = sim$dyad.data, 
            data.monad = sim$monad.data,
            senderID="sender", receiverID="receiver",
            nodeID="node", timeID="year",
            n.groups=sim$BLK, n.hmmstates=sim$STATE,
            directed=TRUE,
            mmsbm.control = list(verbose = FALSE,
                                 #var_b = c(20, 20),
                                 max_em_iter=10000,
                                 threads = parallel::detectCores()))
  est.nmm[which(v==i)] <- mean(predict(f, type="response"))
  est.mm[which(v==i)] <- mean(predict(f, type="response", parametric_mm=TRUE))
  tblock[[which(v==i)]] <- sim$B
  eblock[[which(v==i)]] <- f$BlockModel
  tmonad[[which(v==i)]] <- sim$beta_arr
  emonad[[which(v==i)]] <- f$MonadCoef
  print(which(v==i))
}

plot(tm, est.nmm, xlim=c(0, 1), ylim=c(0,1))
points(tm, est.mm, col="red")

plot(tm, est.nmm, xlim=c(0, .2), ylim=c(0,.2))
points(tm, est.mm, col="red")

save(est.nmm, est.mm, tm, tblock, eblock, tmonad, emonad, file="~/Dropbox/netsims.Rdata")

library(combinat)
cs <- permn(1:3)
bcor <- sapply(1:length(eblock), function(x){
  cors <- lapply(cs, function(y){
    cor(c(eblock[[x]][y,y]), c(tblock[[x]]))
    })
  return(max(unlist(cors)))
  })

plot(tm, bcor)
lm(bcor ~ tm)


hs <- permn(1:2)
mcor <- sapply(1:length(emonad), function(x){
  cors <- lapply(cs, function(y){
    cor(c(emonad[[x]][,y,hs[[1]]]), c(tmonad[[x]]))
    })
  cors2 <- lapply(cs, function(y){
    cor(c(emonad[[x]][,y,hs[[2]]]), c(tmonad[[x]]))
    })
  return(max(unlist(c(cors, cors2))))
  })

plot(tm, mcor)



@


<<1b, eval=TRUE, echo=FALSE, comment=NA, message=FALSE, warning=FALSE, tidy=TRUE>>=
library(NetMix)
#load("~/Dropbox/socnet/DynSocNet_Package/tests/fit_onset_4blocks2states.Rdata")  
load("~/Dropbox/NetMix/tests/fit_onset_4blocks2states.Rdata")  
load("~/Dropbox/NetMix/tests/MID_data.Rdata") 
load("~/Dropbox/NetMix/tests/MIDdata.Rdata") 

fit_onset$monadic.data$`(nid)`[fit_onset$monadic.data$`(nid)` == "Côte D'Ivoire"] <- "Cote d'Ivoire"
fit_onset$dyadic.data$`(sid)`[fit_onset$dyadic.data$`(sid)` == "Côte D'Ivoire"] <- "Cote d'Ivoire"
fit_onset$dyadic.data$`(rid)`[fit_onset$dyadic.data$`(rid)` == "Côte D'Ivoire"] <- "Cote d'Ivoire"
@ 

\bigskip

\noindent The mmsbm.fit() function fits the model and returns the estimated monadic and dyadic coefficients, blockmodel of edge formation probabilities, cluster membership probabilities for each node-year, latent state probabilities for each year, and matrix of transition probabilities between latent states.  The summary.net() function reports summary statistics, coefficients, and estimated cluster membership.  cluster.top() returns the nodes that have the highest estimated membership in each cluster, on average.

\bigskip
<<2, eval=TRUE, comment=NA, message=FALSE, warning=FALSE, tidy=FALSE>>=
summary(fit_onset) 
colMeans(exp(fit_onset$BlockModel) / (1 + exp(fit_onset$BlockModel)))
@ 

\noindent We can graphically summarize results by plotting the blockmodel as a network of clusters linked by edge formation probabilities.  The size of each cluster is proportional to the sum of nodes' membership in that cluster (Cluster size = $\sum\limits_p \sum\limits_t \sum\limits_m \pi_{p,t,m})$, and edge thickness is proportional to the edge formation probabilities from the blockmodel.

<<3, eval=FALSE, echo=FALSE, comment=NA, message=FALSE, warning=FALSE, fig=TRUE, tidy=FALSE>>=
par(mfrow=c(1,1))
pdf("plot_onset.pdf")
plot(fit_onset)
dev.off()
@ 

<<4a, eval=FALSE, echo=FALSE, comment=NA, message=FALSE, warning=FALSE, fig=TRUE, tidy=FALSE>>=
## Group 4 is "conflict prone" observations -- closely tracks conflict rates
pdf("G2.pdf", height=6, width=8)
plot(unique(fit_onset$dyadic.data$`(tid)`), 
     tapply(fit_onset$MixedMembership[1,], fit_onset$monadic.data$`(tid)`, mean),
     type="l", lwd=2, xlab="",
     ylab="Group 2 Avg. Membership", ylim=c(0.12, 0.48))
lines(unique(MID_dyad$year), 0.16+tapply(MID_dyad$MID_onset, MID_dyad$year, mean)*2, lwd=2, col="red")
axis(side=4, at=c(0.15, 0.25, 0.35, 0.45),
     labels=(c(0.15, 0.25, 0.35, 0.45)-0.16)/2,
     ylab="test")
text(x=1865, y=0.32, "Group 2 Avg. Membership")
text(x=1865, y=0.14, "MID Onset Rate", col="red")
dev.off()
@ 

\includegraphics[scale=1]{plot_onset}

\includegraphics[scale=1]{G2}

%\vspace{-20mm}
\noindent We can depict average cluster membership by time period ($Avg.Cluster_{t} =   \sum_{p} \sum_{m} \pi_{p,t,m}$) or node ($Avg.Cluster_{p} =   \sum_{t} \sum_{m} \pi_{p,t,m}$)

<<4, eval=TRUE, comment=NA, message=FALSE, warning=FALSE, fig=TRUE, tidy=FALSE>>=
cluster.time(fit_onset) 

## Manually check coalitions during the Cold War
cluster.mems(fit_onset, 1950:1990, 20)

## A different way to look at this: subtract mean from each cluster, look at dominant membership
#cluster.mems(fit_onset, 1955:1990, demean=TRUE)
@ 

 
\noindent We can similarly examine cluster membership for individual nodes over time ($Cluster_{p,t} = \sum_m \pi_{p,t,m}$).

<<5, eval=FALSE, comment=NA, message=FALSE, warning=FALSE, tidy=FALSE>>=
cluster.time.node(fit_onset) 
@ 

<<6, eval=FALSE, echo=FALSE, comment=NA, message=FALSE, warning=FALSE, tidy=FALSE>>=

plot.states <- function(fm, x){
  require(ggplot2)
  plots <- list()
  ind <- 1
  for(i in x){
    Nodes <- unlist(lapply(strsplit(colnames(fm$MixedMembership), "@"), "[[", 1))
    avgmem <- lapply(1:nrow(fm$MixedMembership), function(x){
      fm$MixedMembership[x,which(Nodes==i)]
      })
    ts <- unlist(lapply(strsplit(names(avgmem[[1]]), "@"), "[[", 2))
    avgmem <- as.data.frame(cbind(rep(ts, nrow(fm$MixedMembership)), unlist(avgmem),
                                   rep(1:nrow(fm$MixedMembership), each=length(ts))))
    colnames(avgmem) <- c("Time", "Membership", "Group")
    avgmem$Group <- factor(avgmem$Group, levels=length(unique(avgmem$Group)):1)
    if(class(avgmem$Membership) == "factor"){avgmem$Membership <- as.numeric(as.character(avgmem$Membership))}
    if(class(avgmem$Time) == "factor"){avgmem$Time <- as.numeric(as.character(avgmem$Time))}
    plots[[ind]] <- ggplot() + ggtitle(paste("Group Membership Over Time,", i)) + 
      theme(plot.title = element_text(hjust = 0.5)) +
      geom_area(aes(y = Membership, x = Time, fill=Group), data = avgmem,
                stat="identity", position="stack")  + guides(fill=guide_legend(title="Group"))
        ind <- ind + 1
  }
  multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                    ncol = cols, nrow = ceiling(numPlots/cols))
  }

 if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
  }
  multiplot(plots[[1]], plots[[2]], plots[[3]], plots[[4]],
          plots[[5]], plots[[6]], cols=3)
}

  
  
  
  
  
states <- c("USA", "Russia", "China", "Switzerland", "Cuba", "Iran")
plots <- list()
  ind <- 1
for(i in states){
    Nodes <- unlist(lapply(strsplit(colnames(fit_onset$MixedMembership), "@"), "[[", 1))
    avgmem <- lapply(1:nrow(fit_onset$MixedMembership), function(x){
      fit_onset$MixedMembership[x,which(Nodes==i)]
      })
    ts <- unlist(lapply(strsplit(names(avgmem[[1]]), "@"), "[[", 2))
    avgmem <- as.data.frame(cbind(rep(ts, nrow(fit_onset$MixedMembership)), unlist(avgmem),
                                   rep(1:nrow(fit_onset$MixedMembership), each=length(ts))))
    colnames(avgmem) <- c("Time", "Membership", "Group")
    avgmem$Group <- factor(avgmem$Group, levels=length(unique(avgmem$Group)):1)
    if(class(avgmem$Membership) == "factor"){avgmem$Membership <- as.numeric(as.character(avgmem$Membership))}
    if(class(avgmem$Time) == "factor"){avgmem$Time <- as.numeric(as.character(avgmem$Time))}
    plots[[ind]] <- ggplot() + ggtitle(paste("Group Membership Over Time,", i)) + theme(plot.title = element_text(hjust = 0.5)) +
      geom_area(aes(y = Membership, x = Time, fill=Group), data = avgmem,
                stat="identity", position="stack")  + guides(fill=guide_legend(title="Group"))
        ind <- ind + 1
}
  
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                    ncol = cols, nrow = ceiling(numPlots/cols))
  }

 if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}
pdf("cluster_time_node_onset.pdf", height=8, width=15)
multiplot(plots[[1]], plots[[2]], plots[[3]], plots[[4]],
          plots[[5]], plots[[6]], cols=3)
dev.off()
@ 

\includegraphics[scale=1]{cluster_time_node_onset}

\noindent Examine distribution of latent markov states over time
<<6b, eval=TRUE, echo=TRUE, comment=NA, message=FALSE, warning=FALSE, tidy=FALSE>>=
pdf("markov.pdf", height=5, width=8)
plot(x=as.numeric(paste(unique(fit_onset$monadic.data$`(tid)`))), 
     y=fit_onset$Kappa[1,], ylim=c(-0.01,1),
     type="l", xlab="", ylab="Markov State 1")
lines(as.numeric(paste(unique(fit_onset$monadic.data$`(tid)`))),
      fit_onset$Kappa[2,], col="red")
dev.off()
@ 
 
\includegraphics[scale=1]{markov}

\vspace{3mm}
\noindent To examine monadic covariate effects, we calculate the change in predicted probability of edge formation when a given node’s covariate value is increased by one unit while other nodes remain at observed covariate values. Because the effect depends on the estimated cluster membership of both nodes in a dyad, this returns a separate estimated effect for each (directed) potential edge:
\\

$\textrm{Effect}_{r,p,q,t} = \Pr(Y_{p,q,t}|x_{r,p,t} = x_{r,p,t} + 1) − Pr(Y_{p,q,t}|x_{r,p,t})$
\\

\noindent The covFX() function calculates this quantity for each potential edge, and also aggregates the estimated effect to the node, year, and network level.

<<7, eval=TRUE, comment=NA, message=FALSE, warning=FALSE, tidy=FALSE>>=
FX <- covFX(fit_onset, "polity", sd(fit_onset$monadic.data[,"polity"]))
names(FX)
FX[[1]] # overall average effect
@ 

The plotFX() function creates a series of plots to summarize estimated effects.

<<8, eval=FALSE, comment=NA, message=FALSE, warning=FALSE, tidy=FALSE>>=
plot.FX(FX, fit_onset)
@ 

<<9, eval=FALSE, echo=FALSE, comment=NA, message=FALSE, warning=FALSE, tidy=FALSE>>=
ymax <- max(hist(FX[[5]], freq=F)[["counts"]])
pdf("FXhist_onset.pdf", height=7, width=6)
  hist(FX[[5]], main="Distribution of Marginal Effects", 
       xlab="Effect on Pr(Edge Formation)", freq=F)
  #lines(x=c(FX[[1]], FX[[1]]), y=c(0,ymax*1.05), col="red", lwd=2)
  #text(x=FX[[1]], y=15000, paste("Avg. Effect =", round(FX[[1]],6)), col="red", pos=2)
dev.off()

pdf("FXtime_onset.pdf", height=6, width=7)
  plot(unique(fit_onset$dyadic.data[,"(tid)"]), tapply(FX[[5]], fit_onset$dyadic.data[,"(tid)"], mean), 
       type="o", 
       xlab="Time", ylab="Effect on Pr(Edge Formation)", main="Marginal Effect over Time")
  abline(h=0, lty=2)
dev.off()

pdf("FXnode_onset.pdf", height=12, width=7)
states <- names(sort(table(fit_onset$monadic.data[,"(nid)"]), decreasing=T))[1:60]
nodes <- sort(FX[[3]])[names(sort(FX[[3]])) %in% states]
  plot(1, type="n", xlab="Node-Level Estimated Effect", ylab="", 
       xlim=c(min(FX[[3]]) - sd(FX[[3]]), max(FX[[3]]) + 5*sd(FX[[3]])),
       ylim = c(0, length(nodes)), yaxt="n")
  for(i in 1:length(nodes)){
    points(nodes[i],i, pch=19)
    text(nodes[i],i, names(nodes)[i], pos=4, cex=0.7)
  }
  abline(v=0, lty=2, lwd=2, col="red")
dev.off()
@ 

\includegraphics{FXhist_onset.pdf}
\\
\includegraphics{FXtime_onset.pdf}
\\
\includegraphics[keepaspectratio=true, scale=0.1]{FXnode_onset.pdf}

\noindent We can also examine heterogeneity in covariate effects over time within specific countries.
<<9b, eval=FALSE, echo=FALSE, comment=NA, message=FALSE, warning=FALSE, tidy=FALSE>>=
pdf("CountryHet.pdf", height=6, width=9)
par(mfrow=c(2,3))

US <- fit_onset$dyadic.data$`(sid)`=="United States of America" | fit_onset$dyadic.data$`(rid)`=="United States of America"
US.dem <- tapply(FX[[5]][,US], fit_onset$dyadic.data$`(tid)`[US], mean)
plot(names(US.dem), US.dem, type="l", ylim=c(-1.5e-3, 7e-3), xlim=c(1816, 2010),
     xlab="", ylab="Effect of Polity", main="United States")
par(xpd = F) 
abline(h=0, lty=2)

Rus <- fit_onset$dyadic.data$`(sid)`=="Russian Federation" | fit_onset$dyadic.data$`(rid)`=="Russian Federation"
Rus.dem <- tapply(FX[[5]][,Rus], fit_onset$dyadic.data$`(tid)`[Rus], mean)
plot(names(Rus.dem), Rus.dem, type="l", ylim=c(-1.5e-3, 7e-3), xlim=c(1816, 2010),
     xlab="", ylab="Effect of Polity", main="Russia")
par(xpd = F) 
abline(h=0, lty=2)

Col <- fit_onset$dyadic.data$`(sid)`=="Colombia" | fit_onset$dyadic.data$`(rid)`=="Colombia"
Col.dem <- tapply(FX[[5]][,Col], fit_onset$dyadic.data$`(tid)`[Col], mean)
plot(names(Col.dem), Col.dem, type="l",  ylim=c(-1.5e-3, 7e-3),xlim=c(1816, 2010),
     xlab="", ylab="Effect of Polity", main="Colombia")
par(xpd = F) 
abline(h=0, lty=2)


Swi <- fit_onset$dyadic.data$`(sid)`=="Switzerland" | fit_onset$dyadic.data$`(rid)`=="Switzerland"
Swi.dem <- tapply(FX[[5]][,Swi], fit_onset$dyadic.data$`(tid)`[Swi], mean)
plot(names(Swi.dem), Swi.dem, type="l", ylim=c(-1.5e-3, 7e-3), xlim=c(1816, 2010),
     xlab="", ylab="Effect of Polity", main="Switzerland")
par(xpd = F) 
abline(h=0, lty=2)


Chn <- fit_onset$dyadic.data$`(sid)`=="China" | fit_onset$dyadic.data$`(rid)`=="China"
Chn.dem <- tapply(FX[[5]][,Chn], fit_onset$dyadic.data$`(tid)`[Chn], mean)
plot(names(Chn.dem), Chn.dem, type="l", ylim=c(-1.5e-3, 7e-3), xlim=c(1816, 2010),
     xlab="", ylab="Effect of Polity", main="China")
par(xpd = F) 
abline(h=0, lty=2)


NZ <- fit_onset$dyadic.data$`(sid)`=="New Zealand" | fit_onset$dyadic.data$`(rid)`=="New Zealand"
NZ.dem <- tapply(FX[[5]][,NZ], fit_onset$dyadic.data$`(tid)`[NZ], mean)
plot(names(NZ.dem), NZ.dem, type="l",  ylim=c(-1.5e-3, 7e-3), xlim=c(1816, 2010),
     xlab="", ylab="Effect of Polity", main="New Zealand")
par(xpd = F) 
abline(h=0, lty=2)

dev.off()

@

\includegraphics[scale=1.9]{CountryHet}


\noindent We also include a predict() function to calculate expected probability of edge formation given any set of user-supplied covariates.

<<10, eval=TRUE, echo=TRUE, comment=NA, message=FALSE, warning=FALSE, tidy=FALSE>>=
monad.data2 <- as.data.frame(fit_onset$monadic.data, stringsAsFactors=FALSE)
monad.data2[,"logcinc"] <- as.numeric(monad.data2[,"logcinc"]) + sd( as.numeric(monad.data2[,"logcinc"]))
predicted <- predict(fit_onset, dyad=fit_onset$dyadic.data, monad=fit_onset$monadic.data)
predicted2 <- predict(fit_onset, dyad=fit_onset$dyadic.data, monad=monad.data2)
mean(predicted2 - predicted) # military capacity decreases conflict, on average
@ 


<<11, eval=FALSE, echo=FALSE, comment=NA, message=FALSE, warning=FALSE, tidy=FALSE>>=
predicted <- predict(fit_onset, dyad=fit_onset$dyadic.data, monad=fit_onset$monadic.data)
true <- as.numeric(fit_onset$dyadic.data[,1])
cor(as.vector(predicted), true)
mean(true)
mean(predicted)

par(mfrow=c(1,2))
hist(predicted[true==0], freq=FALSE, ylim=c(0, 20), xlim=c(0,1))
hist(predicted[true==1], freq=FALSE, ylim=c(0, 20), xlim=c(0,1))
@ 


\noindent Finally, we can compare our results with a standard logit model.  To do so, we need to transform the monadic covariates to match the dyadic structure required in logit.

<<13, eval=TRUE, echo=TRUE, comment=NA, message=FALSE, warning=FALSE, tidy=FALSE>>=
MID_dyad$dem <- ifelse(MID_dyad$polity2_a > 6 & MID_dyad$polity2_b > 6, 1, 0)
MID_dyad$aut <- ifelse(MID_dyad$polity2_a < -6 & MID_dyad$polity2_b < -6, 1, 0)
MID_dyad$mixed <- ifelse(MID_dyad$dem==0 & MID_dyad$aut==0, 1, 0)
MID_dyad$cinc_ratio <- MID_dyad$CINC_a / MID_dyad$CINC_b
logit.MID <- glm(mid_onset ~ hially + lowally + dist + contig_COW +
                   dem + mixed + cinc_ratio + 
                   peaceyrs + spline1 + spline2 + spline3,
                 data = MID, family = binomial(link = "logit"))
@ 

<<13a, eval=FALSE, echo=FALSE, comment=NA, message=FALSE, warning=FALSE, tidy=FALSE>>=
set.seed(9999)
MMSB.dyad <- mmsbm(formula.dyad = mid_onset ~ hially + lowally + dist + 
                     contig_COW + dem + mixed + cinc_ratio + 
                     peaceyrs + spline1 + spline2 + spline3,
                   data.dyad = MID, 
                   data.monad = MID.monad,
                   senderID = "country1", receiverID = "country2", 
                   nodeID = "country", 
                   timeID = "year",
                   n.blocks = 4, 
                   n.hmmstates = 2,
                   directed=FALSE,
                   mmsbm.control = list(var_b = c(9, 9),
                                                    var_gamma = 9,
                                                    verbose = TRUE,
                                                    em_iter = 3000,
                                                    threads = parallel::detectCores()
                                                    ))
@ 

<<13b, eval=TRUE, echo=FALSE, comment=NA, message=FALSE, warning=FALSE, tidy=FALSE>>=
load("fit_onset_dyad_4blocks2states.Rdata")
@

\noindent Compare coefficients and in-sample fit.  We compare the logit model to the NetMix model estimated above, as well as a model with only dyadic covariates.

<<13c, eval=T, echo=T, comment=NA, message=FALSE, warning=FALSE, tidy=FALSE>>=
coef(logit.MID)[-1]
fit_onset$DyadCoef 
MMSB.dyad$DyadCoef
@

<<13d, eval=F, echo=F, comment=NA, message=FALSE, warning=FALSE, tidy=FALSE>>=
pred.logit <- predict(logit.MID, newdata = MID)
pred.MMSB <- predict(fit_onset, posterior.pi=F)
pred.MMSBd <- predict(MMSB.dyad, posterior.pi=F)


library(ROCR)
MID.roc <- prediction(predictions=c(pred.MMSB), labels=fit_onset$dyadic.data$mid_onset)
MID.roc2 <- performance(MID.roc, measure="tpr", x.measure="fpr")

MID.rocD <- prediction(predictions=c(pred.MMSBd), labels=fit_onset$dyadic.data$mid_onset)
MID.roc2D <- performance(MID.rocD, measure="tpr", x.measure="fpr")

logit.roc <- prediction(predictions=c(pred.logit), labels=MID_dyad$mid_onset)
logit.roc2 <- performance(logit.roc, measure="tpr", x.measure="fpr")


pdf("ROC_onset.pdf", width=7, height=7)
par(mfrow=c(1,1))
plot(unlist(attributes(MID.roc2)["x.values"]), 
     unlist(attributes(MID.roc2)["y.values"]),
     type="l",
     xlab="False Positive Rate",
     ylab="True Positive Rate", lwd=2)
lines(unlist(attributes(logit.roc2)["x.values"]),
      unlist(attributes(logit.roc2)["y.values"]),
      col="red", lwd=2)
lines(unlist(attributes(MID.roc2D)["x.values"]),
      unlist(attributes(MID.roc2D)["y.values"]),
      col="dark green", lwd=2)
lines(c(0, 1), c(0,1), lty=2)
legend(x=0.7, y=0.2, legend=c("hmmsb", "hmmsb w/ dyadic covs", "logit"),
       col=c("black", "dark green", "red"), lty=1, lwd=2)
dev.off()
@ 

\includegraphics{ROC_onset.pdf}

\noindent Compare out-of-sample prediction.

<<14, eval=TRUE, echo=TRUE, comment=NA, message=FALSE, warning=FALSE, tidy=FALSE>>=
## Fit model up to 2008
MID.sub <- MID[MID_dyad$year <= 2008,]
MID.monad.sub <- MID.monad[as.numeric(paste(MID.monad$year)) <= 2008,]
@ 

<<14b, eval=FALSE, echo=TRUE, comment=NA, message=FALSE, warning=FALSE, tidy=FALSE>>=
## Refit hmmsb and logit models
set.seed(9999)
fit_onset2008 <- mmsbm(formula.dyad = mid_onset ~ hially + lowally + 
                                     dist + contig_COW + peaceyrs + 
                                     spline1 + spline2 + spline3,
                               formula.monad =  ~ polity + logcinc,
                               data.dyad = MID.sub, 
                               data.monad = MID.monad.sub,
                               senderID = "country1", receiverID = "country2", 
                               nodeID = "country", 
                               timeID = "year",
                               n.blocks = 4, 
                               n.hmmstates = 2,
                               directed=FALSE,
                               mmsbm.control = list(var_b = c(9, 9),
                                                    var_gamma = 9,
                                                    verbose = TRUE,
                                                    em_iter = 3000,
                                                    threads = parallel::detectCores()
                                                    ))

fit_onset2008D <- mmsbm(formula.dyad = mid_onset ~ hially + lowally + dist + contig_COW +
                          dem + mixed + cinc_ratio + 
                          peaceyrs + spline1 + spline2 + spline3,
                               data.dyad = MID.sub, 
                               data.monad = MID.monad.sub,
                               senderID = "country1", receiverID = "country2", 
                               nodeID = "country", 
                               timeID = "year",
                               n.blocks = 4, 
                               n.hmmstates = 2,
                               directed=FALSE,
                               mmsbm.control = list(var_b = c(9, 9),
                                                    var_gamma = 9,
                                                    verbose = TRUE,
                                                    em_iter = 3000,
                                                    threads = parallel::detectCores()
                                                    ))

logit2008 <- glm(mid_onset ~ hially + lowally + dist + contig_COW +
                   dem + mixed + cinc_ratio + 
                   peaceyrs + spline1 + spline2 + spline3,
                 data = MID.sub, family = binomial(link = "logit"))
@ 


<<14c, eval=TRUE, echo=FALSE, comment=NA, message=FALSE, warning=FALSE, tidy=FALSE>>=
load("fit_onset2008_4blocks2states.Rdata")
load("fit_onset_2008D_4blocks2states.Rdata")
logit2008 <- glm(mid_onset ~ hially + lowally + dist + contig_COW +
                   dem + mixed + cinc_ratio + 
                   peaceyrs + spline1 + spline2 + spline3,
                 data = MID.sub, family = binomial(link = "logit"))
@ 

<<14c, eval=FALSE, echo=FALSE, comment=NA, message=FALSE, warning=FALSE, tidy=FALSE>>=
MID.new <- MID[MID_dyad$year %in% 2009:2010,]
MID.monad.new <- MID.monad[as.numeric(paste(MID.monad$year)) %in% 2009:2010,]

## Predict years 2009-10 
MMSB.predictOOS <- predict(fit_onset2008, dyad=MID.new, monad=MID.monad.new,
                     out.sample=TRUE)
MMSB.predictOOSD <- predict(fit_onset2008D, dyad=MID.new, monad=MID.monad.new,
                     out.sample=TRUE)
logit.predictOOS <- predict(logit2008, newdata=MID.new)

## Calculate ROC curve

library(ROCR)
MMSB.roc <- prediction(predictions=c(MMSB.predictOOS), labels=MID.new$mid_onset)
MMSB.roc2 <- performance(MMSB.roc, measure="tpr", x.measure="fpr")

MMSB.rocD <- prediction(predictions=c(MMSB.predictOOSD), labels=MID.new$mid_onset)
MMSB.roc2D <- performance(MMSB.rocD, measure="tpr", x.measure="fpr")

logit.roc <- prediction(predictions=c(logit.predictOOS), labels=MID.new$mid_onset)
logit.roc2 <- performance(logit.roc, measure="tpr", x.measure="fpr")

pdf("ROC_onsetOOS.pdf", height=8, width=8)
par(mfrow=c(1,1))
plot(unlist(attributes(MMSB.roc2)["x.values"]), 
     unlist(attributes(MMSB.roc2)["y.values"]),
     type="l",
     xlab="False Positive Rate",
     ylab="True Positive Rate", lwd=2)
lines(unlist(attributes(logit.roc2)["x.values"]),
      unlist(attributes(logit.roc2)["y.values"]),
      type="l",
      col="red", lwd=2)
lines(unlist(attributes(MMSB.roc2D)["x.values"]),
      unlist(attributes(MMSB.roc2D)["y.values"]),
      type="l",
      col="dark green", lwd=2)
lines(c(0, 1), c(0,1), lty=2)
legend(x=0.7, y=0.2, legend=c("hmmsb", "hmmsb w/ dyadic covariates", "logit"),
       col=c("black", "dark green", "red"), lty=1, lwd=2)
dev.off()

## Area under the ROC curve
performance(MMSB.roc, measure = "auc")@y.values
performance(MMSB.rocD, measure = "auc")@y.values
performance(logit.roc, measure = "auc")@y.values
@ 


<<143, eval=TRUE, echo=TRUE, comment=NA, message=FALSE, warning=FALSE, tidy=FALSE>>=
MID.new <- MID[MID_dyad$year %in% 2009:2010,]
MID.monad.new <- MID.monad[as.numeric(paste(MID.monad$year)) %in% 2009:2010,]

## Predict years 2009-10 
MMSB.predictOOS <- predict(fit_onset2008, dyad=MID.new, monad=MID.monad.new,
                     out.sample=TRUE)
MMSB.predictOOSD <- predict(fit_onset2008D, dyad=MID.new, monad=MID.monad.new,
                     out.sample=TRUE)
logit.predictOOS <- predict(logit2008, newdata=MID.new)

## Calculate ROC curve
library(ROCR)
MMSB.roc <- prediction(predictions=c(MMSB.predictOOS), labels=MID.new$mid_onset)
MMSB.rocD <- prediction(predictions=c(MMSB.predictOOSD), labels=MID.new$mid_onset)
logit.roc <- prediction(predictions=c(logit.predictOOS), labels=MID.new$mid_onset)

## Area under the ROC curve
performance(logit.roc, measure = "auc")@y.values
performance(MMSB.rocD, measure = "auc")@y.values
performance(MMSB.roc, measure = "auc")@y.values
@ 


\includegraphics{ROC_onsetOOS.pdf}


\noindent Can also compare netmix models with different numbers of blocks.
<<13d, eval=FALSE, echo=TRUE, comment=NA, message=FALSE, warning=FALSE, tidy=FALSE>>=
files <- c("~/Documents/NetMix/tests/fit_onset_2blocks2states.Rdata",
           "~/Documents/NetMix/tests/fit_onset_3blocks2states.Rdata",
           "~/Documents/NetMix/tests/fit_onset_4blocks2states.Rdata",
           "~/Documents/NetMix/tests/fit_onset_5blocks2states.Rdata")
dyadic <- matrix(nrow=length(files), ncol=length(fit_onset$DyadCoef))
for(i in files){
  eval(parse(text = paste("load('", i, "')", sep="")))
  dyadic[which(files==i),] <- fit_onset$DyadCoef
}
pdf("hially.pdf", height=5, width=8)
plot(1:4, dyadic[1:4,1], main="hially coefficient",
     ylim=c(0, 1),
     ylab="estimate",
     xlab="Number of Blocks")
dev.off()

pdf("contig.pdf", height=5, width=8)
plot(1:4, dyadic[1:4,4], main="contiguity coefficient",
     ylim=c(0, 1),
     ylab="estimate",
     xlab="Number of Blocks")
dev.off()

@ 

\includegraphics{hially}

\includegraphics{contig}


<<15, eval=FALSE, echo=FALSE, comment=NA, message=FALSE, warning=FALSE, tidy=FALSE>>=
## parametric bootstrapping for standard errors
# leads to forced quit of R

## Figure out why? -- upload this to Git
mean(predict(fit_onset, type="response"))
mean(predict(fit_onset, posterior.pi=T, type="response"))

MID_dyad$MID_onset.sim <- predict(fit_onset, type="response")
fit_onset.sim <- mmsbm(formula.dyad = MID_onset.sim ~ hially + lowally + dist + contig_COW + 
                               peaceyrs + spline1 + spline2 + spline3,
                               formula.monad =  ~ polity + logcinc,
                               data.dyad = MID, data.monad = MID.monad,
                               senderID = "country1", receiverID = "country2", 
                               nodeID = "country", 
                               timeID = "year",
                               n.blocks = 4, 
                               n.hmmstates = 2,
                               directed=FALSE,
                               mmsbm.control = list(var_b = c(9, 9),
                                                    var_gamma = 9,
                                                    verbose = TRUE,
                                                    em_iter = 3000,
                                                    threads = parallel::detectCores()
                                                    ))
summary(fit_onset.sim)


@ 





\end{document}